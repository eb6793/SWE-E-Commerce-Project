{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNetworkError = isNetworkError;\nexports.isRetryableError = isRetryableError;\nexports.isSafeRequestError = isSafeRequestError;\nexports.isIdempotentRequestError = isIdempotentRequestError;\nexports.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\nexports.exponentialDelay = exponentialDelay;\nexports.default = axiosRetry;\n\nvar _isRetryAllowed = require('is-retry-allowed');\n\nvar _isRetryAllowed2 = _interopRequireDefault(_isRetryAllowed);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar namespace = 'axios-retry';\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\nfunction isNetworkError(error) {\n  return !error.response && Boolean(error.code) && // Prevents retrying cancelled requests\n  error.code !== 'ECONNABORTED' && // Prevents retrying timed out requests\n  (0, _isRetryAllowed2.default)(error); // Prevents retrying unsafe errors\n}\n\nvar SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nvar IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\nfunction isRetryableError(error) {\n  return error.code !== 'ECONNABORTED' && (!error.response || error.response.status >= 500 && error.response.status <= 599);\n}\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\n\nfunction isSafeRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\n\nfunction isIdempotentRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\n\nfunction isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error);\n}\n/**\n * @return {number} - delay in milliseconds, always 0\n */\n\n\nfunction noDelay() {\n  return 0;\n}\n/**\n * @param  {number} [retryNumber=0]\n * @return {number} - delay in milliseconds\n */\n\n\nfunction exponentialDelay() {\n  var retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var delay = Math.pow(2, retryNumber) * 100;\n  var randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n\n  return delay + randomSum;\n}\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @return {Object}\n */\n\n\nfunction getCurrentState(config) {\n  var currentState = config[namespace] || {};\n  currentState.retryCount = currentState.retryCount || 0;\n  config[namespace] = currentState;\n  return currentState;\n}\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {AxiosRetryConfig} defaultOptions\n * @return {AxiosRetryConfig}\n */\n\n\nfunction getRequestOptions(config, defaultOptions) {\n  return Object.assign({}, defaultOptions, config[namespace]);\n}\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\n\n\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent;\n  }\n\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Exponential back-off retry delay between requests\n * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});\n *\n * // Custom retry delay\n * axiosRetry(axios, { retryDelay : (retryCount) => {\n *   return retryCount * 1000;\n * }});\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {boolean} [defaultOptions.shouldResetTimeout=false]\n *        Defines if the timeout should be reset between retries\n * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]\n *        A function to determine if the error can be retried\n * @param {Function} [defaultOptions.retryDelay=noDelay]\n *        A function to determine the delay between retry requests\n */\n\n\nfunction axiosRetry(axios, defaultOptions) {\n  axios.interceptors.request.use(function (config) {\n    var currentState = getCurrentState(config);\n    currentState.lastRequestTime = Date.now();\n    return config;\n  });\n  axios.interceptors.response.use(null, function (error) {\n    var config = error.config; // If we have no information to retry the request\n\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    var _getRequestOptions = getRequestOptions(config, defaultOptions),\n        _getRequestOptions$re = _getRequestOptions.retries,\n        retries = _getRequestOptions$re === undefined ? 3 : _getRequestOptions$re,\n        _getRequestOptions$re2 = _getRequestOptions.retryCondition,\n        retryCondition = _getRequestOptions$re2 === undefined ? isNetworkOrIdempotentRequestError : _getRequestOptions$re2,\n        _getRequestOptions$re3 = _getRequestOptions.retryDelay,\n        retryDelay = _getRequestOptions$re3 === undefined ? noDelay : _getRequestOptions$re3,\n        _getRequestOptions$sh = _getRequestOptions.shouldResetTimeout,\n        shouldResetTimeout = _getRequestOptions$sh === undefined ? false : _getRequestOptions$sh;\n\n    var currentState = getCurrentState(config);\n    var shouldRetry = retryCondition(error) && currentState.retryCount < retries;\n\n    if (shouldRetry) {\n      currentState.retryCount += 1;\n      var delay = retryDelay(currentState.retryCount, error); // Axios fails merging this configuration to the default configuration because it has an issue\n      // with circular structures: https://github.com/mzabriskie/axios/issues/370\n\n      fixConfig(axios, config);\n\n      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        var lastRequestDuration = Date.now() - currentState.lastRequestTime; // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)\n\n        config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);\n      }\n\n      config.transformRequest = [function (data) {\n        return data;\n      }];\n      return new Promise(function (resolve) {\n        return setTimeout(function () {\n          return resolve(axios(config));\n        }, delay);\n      });\n    }\n\n    return Promise.reject(error);\n  });\n} // Compatibility with CommonJS\n\n\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.isRetryableError = isRetryableError;","map":{"version":3,"sources":["../es/index.js"],"names":["namespace","isNetworkError","error","Boolean","SAFE_HTTP_METHODS","IDEMPOTENT_HTTP_METHODS","isRetryableError","isSafeRequestError","isIdempotentRequestError","isNetworkOrIdempotentRequestError","exponentialDelay","retryNumber","delay","Math","randomSum","currentState","config","Object","axios","axiosRetry","getCurrentState","Date","Promise","retries","retryCondition","retryDelay","shouldResetTimeout","getRequestOptions","shouldRetry","fixConfig","lastRequestDuration","resolve"],"mappings":"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","sourcesContent":["import isRetryAllowed from 'is-retry-allowed';\n\nconst namespace = 'axios-retry';\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkError(error) {\n  return (\n    !error.response &&\n    Boolean(error.code) && // Prevents retrying cancelled requests\n    error.code !== 'ECONNABORTED' && // Prevents retrying timed out requests\n    isRetryAllowed(error)\n  ); // Prevents retrying unsafe errors\n}\n\nconst SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nconst IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isRetryableError(error) {\n  return (\n    error.code !== 'ECONNABORTED' &&\n    (!error.response || (error.response.status >= 500 && error.response.status <= 599))\n  );\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isSafeRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isIdempotentRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error);\n}\n\n/**\n * @return {number} - delay in milliseconds, always 0\n */\nfunction noDelay() {\n  return 0;\n}\n\n/**\n * @param  {number} [retryNumber=0]\n * @return {number} - delay in milliseconds\n */\nexport function exponentialDelay(retryNumber = 0) {\n  const delay = Math.pow(2, retryNumber) * 100;\n  const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n  return delay + randomSum;\n}\n\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @return {Object}\n */\nfunction getCurrentState(config) {\n  const currentState = config[namespace] || {};\n  currentState.retryCount = currentState.retryCount || 0;\n  config[namespace] = currentState;\n  return currentState;\n}\n\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {AxiosRetryConfig} defaultOptions\n * @return {AxiosRetryConfig}\n */\nfunction getRequestOptions(config, defaultOptions) {\n  return Object.assign({}, defaultOptions, config[namespace]);\n}\n\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent;\n  }\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\n\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Exponential back-off retry delay between requests\n * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});\n *\n * // Custom retry delay\n * axiosRetry(axios, { retryDelay : (retryCount) => {\n *   return retryCount * 1000;\n * }});\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {boolean} [defaultOptions.shouldResetTimeout=false]\n *        Defines if the timeout should be reset between retries\n * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]\n *        A function to determine if the error can be retried\n * @param {Function} [defaultOptions.retryDelay=noDelay]\n *        A function to determine the delay between retry requests\n */\nexport default function axiosRetry(axios, defaultOptions) {\n  axios.interceptors.request.use(config => {\n    const currentState = getCurrentState(config);\n    currentState.lastRequestTime = Date.now();\n    return config;\n  });\n\n  axios.interceptors.response.use(null, error => {\n    const config = error.config;\n\n    // If we have no information to retry the request\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    const {\n      retries = 3,\n      retryCondition = isNetworkOrIdempotentRequestError,\n      retryDelay = noDelay,\n      shouldResetTimeout = false\n    } = getRequestOptions(config, defaultOptions);\n\n    const currentState = getCurrentState(config);\n\n    const shouldRetry = retryCondition(error) && currentState.retryCount < retries;\n\n    if (shouldRetry) {\n      currentState.retryCount += 1;\n      const delay = retryDelay(currentState.retryCount, error);\n\n      // Axios fails merging this configuration to the default configuration because it has an issue\n      // with circular structures: https://github.com/mzabriskie/axios/issues/370\n      fixConfig(axios, config);\n\n      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        const lastRequestDuration = Date.now() - currentState.lastRequestTime;\n        // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)\n        config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);\n      }\n\n      config.transformRequest = [data => data];\n\n      return new Promise(resolve => setTimeout(() => resolve(axios(config)), delay));\n    }\n\n    return Promise.reject(error);\n  });\n}\n\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.isRetryableError = isRetryableError;\n"]},"metadata":{},"sourceType":"script"}